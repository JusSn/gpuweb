<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=600">
<title>Web GPU Cube demo</title>
<script src="gl-matrix-min.js"></script>
</head>
<body>
<canvas height=1000 width=1000></canvas>
<script>
/*******
* This preview of Web GPU uses WHLSL as its shading language. 
* The choice of shading language(s) that will be ingested by the API is still under deliberation. 
*******/
const shader = `
struct FragmentData {
    float4 position : SV_Position;
    float4 color : attribute(0);
};

vertex FragmentData vertex_main(float4 position : attribute(0),
                                float4 color : attribute(1),
                                constant float4x4* modelViewProjectionMatrix : register(b0)) : SV_Position {
    FragmentData output;

    output.position = *modelViewProjectionMatrix * position;
    output.color = color;

    return output;
}

fragment float4 fragment_main(float4 color : attribute(0)) : SV_Target 0 {
    return color;
}
`

const vertexSize = 4 * 8; // Byte size of one cube vertex.
const colorOffset = 4 * 4; // Byte offset of cube vertex color attribute.
const cubeVerticesArray = new Float32Array([
    // float4 position, float4 color
    1, -1, 1, 1, 1, 0, 1, 1,
    -1, -1, 1, 1, 0, 0, 1, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,
    1, -1, -1, 1, 1, 0, 0, 1,
    1, -1, 1, 1, 1, 0, 1, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,

    1, 1, 1, 1, 1, 1, 1, 1,
    1, -1, 1, 1, 1, 0, 1, 1,
    1, -1, -1, 1, 1, 0, 0, 1,
    1, 1, -1, 1, 1, 1, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, -1, -1, 1, 1, 0, 0, 1,

    -1, 1, 1, 1, 0, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, -1, 1, 1, 1, 0, 1,
    -1, 1, -1, 1, 0, 1, 0, 1,
    -1, 1, 1, 1, 0, 1, 1, 1,
    1, 1, -1, 1, 1, 1, 0, 1,

    -1, -1, 1, 1, 0, 0, 1, 1,
    -1, 1, 1, 1, 0, 1, 1, 1,
    -1, 1, -1, 1, 0, 1, 0, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,
    -1, -1, 1, 1, 0, 0, 1, 1,
    -1, 1, -1, 1, 0, 1, 0, 1,

    1, 1, 1, 1, 1, 1, 1, 1,
    -1, 1, 1, 1, 0, 1, 1, 1,
    -1, -1, 1, 1, 0, 0, 1, 1,
    -1, -1, 1, 1, 0, 0, 1, 1,
    1, -1, 1, 1, 1, 0, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,

    1, -1, -1, 1, 1, 0, 0, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,
    -1, 1, -1, 1, 0, 1, 0, 1,
    1, 1, -1, 1, 1, 1, 0, 1,
    1, -1, -1, 1, 1, 0, 0, 1,
    -1, 1, -1, 1, 0, 1, 0, 1,
]);

async function init() {
    /* Context, Device, SwapChain */
    const adapter = await gpu.requestAdapter();
    const device = await adapter.requestDevice();

    const canvas = document.querySelector('canvas');

    const aspect = Math.abs(canvas.width / canvas.height);
    let projectionMatrix = mat4.create();
    mat4.perspective(projectionMatrix, (2 * Math.PI) / 5, aspect, 1, 100.0);

    const context = canvas.getContext('gpu');

    const swapChainDescriptor = {
        context: context,
        format: "bgra8unorm"
    };

    const swapChain = device.createSwapChain(swapChainDescriptor);

    /* Shader Module */
    const shaderModuleDescriptor = { code: shader, isWHLSL: true };
    const shaderModule = device.createShaderModule(shaderModuleDescriptor);

    const verticesBufferDescriptor = {
        size: cubeVerticesArray.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.TRANSFER_DST
    };
    const verticesBuffer = device.createBuffer(verticesBufferDescriptor);
    verticesBuffer.setSubData(0, cubeVerticesArray.buffer);

    /* Input State */
    const positionAttributeDescriptor = {
        attributeIndex: 0,
        offset: 0,
        format: "float4"
    };
    const colorAttributeDescriptor = {
        attributeIndex: 1,
        offset: colorOffset,
        format: "float4"
    }
    const vertexBufferDescriptor = {
        stride: vertexSize,
        stepMode: "vertex",
        attributes: [positionAttributeDescriptor, colorAttributeDescriptor]
    };
    const inputStateDescriptor = {
        indexFormat: "uint32",
        vertexBuffers: { 0: vertexBufferDescriptor }
    };

    /* Bind Group Layout */
    const transformBufferBindGroupLayoutBinding = {
        binding: 0,
        visibility: GPUShaderStageBit.VERTEX,
        type: "uniform-buffer"
    };

    const uniformsBindGroupLayoutDescriptor = {
        bindings: [transformBufferBindGroupLayoutBinding]
    };
    const uniformsBindGroupLayout = device.createBindGroupLayout(uniformsBindGroupLayoutDescriptor);

    /* Render Pipeline */
    const depthStateDescriptor = {
        depthWriteEnabled: true,
        depthCompare: "less"
    };

    const vertexStageDescriptor = {
        module: shaderModule,
        entryPoint: "vertex_main"
    };
    const fragmentStageDescriptor = {
        module: shaderModule,
        entryPoint: "fragment_main"
    };
    const pipelineDescriptor = {
        bindGroupLayouts: [uniformsBindGroupLayout],

        vertexStage: vertexStageDescriptor,
        fragmentStage: fragmentStageDescriptor,

        primitiveTopology: "triangle-list",
        depthStencilState: depthStateDescriptor,
        inputState: inputStateDescriptor
    };
    const pipeline = device.createRenderPipeline(pipelineDescriptor);

    /* Renderpass Attachments */
    let colorAttachment = {
        // attachment is acquired in render loop.
        loadOp: "clear",
        storeOp: "store",
        clearColor: { r: 0.5, g: 1.0, b: 1.0, a: 1.0 }
    };

    // GPUExtent3D
    const depthSize = {
        width: canvas.width,
        height: canvas.height,
        depth: 1
    };

    const depthTextureDescriptor = {
        size: depthSize,
        arrayLayerCount: 1,
        mipLevelCount: 1,
        sampleCount: 1,
        dimension: "2d",
        format: "depth32float-stencil8",
        usage: GPUTextureUsage.OUTPUT_ATTACHMENT
    };

    const depthTexture = device.createTexture(depthTextureDescriptor);

    const depthAttachment = {
        attachment: depthTexture.createDefaultView(),

        depthLoadOp: "clear",
        depthStoreOp: "store",
        clearDepth: 1.0
    };

    const renderPassDescriptor = {
        colorAttachments: [colorAttachment],
        depthStencilAttachment: depthAttachment
    };

    render(device, projectionMatrix, swapChain, verticesBuffer, uniformsBindGroupLayout, pipeline, renderPassDescriptor);
}

/* Transform Buffers and Bindings */
const transformSize = 4 * 16;
function updateTransformArray(array, projectionMatrix) {
    let viewMatrix = mat4.create();
    mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -5));
    let now = Date.now() / 1000;
    mat4.rotate(viewMatrix, viewMatrix, 1, vec3.fromValues(Math.sin(now), Math.cos(now), 0));

    let modelViewProjectionMatrix = mat4.create();
    mat4.multiply(modelViewProjectionMatrix, projectionMatrix, viewMatrix);

    for (let i = 0; i < 16; i++) {
        array[i] = modelViewProjectionMatrix[i];
    }
}

const transformBufferDescriptor = {
    size: transformSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.MAP_WRITE
};

function createTransformBindGroupDescriptor(transformBuffer, uniformsBindGroupLayout) {
    const transformBufferBinding = {
        buffer: transformBuffer,
        offset: 0,
        size: transformSize
    };

    const transformBufferBindGroupBinding = {
        binding: 0,
        resource: transformBufferBinding
    };

    return {
        layout: uniformsBindGroupLayout,
        bindings: [transformBufferBindGroupBinding]
    };
}

const mappedGroups = [];

function render(device, projectionMatrix, swapChain, verticesBuffer, uniformsBindGroupLayout, pipeline, renderPassDescriptor) {
    if (mappedGroups.length == 0) {
        // No buffers are mapped and ready for update.
        const buffer = device.createBuffer(transformBufferDescriptor);
        buffer.mapWriteAsync().then(arrayBuffer => {
            const group = device.createBindGroup(createTransformBindGroupDescriptor(buffer, uniformsBindGroupLayout));

            let mappedGroup = { buffer: buffer, arrayBuffer: arrayBuffer, bindGroup: group };
            drawCommands(mappedGroup, device, projectionMatrix, swapChain, verticesBuffer, uniformsBindGroupLayout, pipeline, renderPassDescriptor);
        });
    } else
        drawCommands(mappedGroups.shift(), device, projectionMatrix, swapChain, verticesBuffer, uniformsBindGroupLayout, pipeline, renderPassDescriptor);
}

function drawCommands(mappedGroup, device, projectionMatrix, swapChain, verticesBuffer, uniformsBindGroupLayout, pipeline, renderPassDescriptor) {
    updateTransformArray(new Float32Array(mappedGroup.arrayBuffer), projectionMatrix);
    mappedGroup.buffer.unmap();

    const commandEncoder = device.createCommandEncoder();
    renderPassDescriptor.colorAttachments[0].attachment = swapChain.getCurrentTexture().createDefaultView();
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    // Encode drawing commands.
    passEncoder.setPipeline(pipeline);
    // Vertex attributes
    passEncoder.setVertexBuffers(0, [verticesBuffer], [0]);
    // Bind groups
    passEncoder.setBindGroup(0, mappedGroup.bindGroup);
    // 36 vertices, 1 instance, 0th vertex, 0th instance.
    passEncoder.draw(36, 1, 0, 0);
    passEncoder.endPass();

    device.getQueue().submit([commandEncoder.finish()]);

    // Ready the current buffer for update after GPU is done with it.
    mappedGroup.buffer.mapWriteAsync().then((arrayBuffer) => {
        mappedGroup.arrayBuffer = arrayBuffer;
        mappedGroups.push(mappedGroup);
    });

    requestAnimationFrame(() => { render(device, projectionMatrix, swapChain, verticesBuffer, uniformsBindGroupLayout, pipeline, renderPassDescriptor) });
}

init();
</script>
</body>
</html>